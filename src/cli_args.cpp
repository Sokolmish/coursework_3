#include "cli_args.hpp"
#include "cxxopts.hpp"
#include <fmt/core.h>

static constexpr const char *name = "cw39";
static constexpr const char *vers = "0.2.0";
static constexpr const char *desc =
        "An optimizing compiler for the subset of the C language.";

static constexpr const char *argPreproc = "preproc";
static constexpr const char *argAst = "ast";
static constexpr const char *argRawIr = "ir-raw";
static constexpr const char *argRawCfg = "cfg-raw";
static constexpr const char *argIr = "ir";
static constexpr const char *argCfg = "cfg";
static constexpr const char *argLLVM = "llvm";
static constexpr const char *argASM = "asm";

static constexpr const char *argTraceScanner = "tr-scan";
static constexpr const char *argTraceParser = "tr-parser";

static constexpr const char *envLLC = "CW39_LLC";
static constexpr const char *defaultLLC = "llc";

class CLIArgs::CLIArgs_Impl {
public:
    cxxopts::Options options;
    cxxopts::ParseResult res;

    CLIArgs_Impl(int argc, char **argv);
};

CLIArgs::CLIArgs_Impl::CLIArgs_Impl(int argc, char **argv) : options(name, desc) {
    using namespace cxxopts;

    auto opt = options.add_options();

    opt(argPreproc, "Write preprocessor output",
        value<std::string>()->implicit_value(""));
    opt(argAst, "Write AST",
        value<std::string>()->implicit_value(""));
    opt(argRawIr, "Write IR before optimizations",
        value<std::string>()->implicit_value(""));
    opt(argRawCfg, "Write CFG before optimizations",
        value<std::string>()->implicit_value(""));
    opt(argIr, "Write IR after optimizations",
        value<std::string>()->implicit_value(""));
    opt(argCfg, "Write CFG after optimizations",
        value<std::string>()->implicit_value(""));
    opt(argLLVM, "Write final LLVM",
        value<std::string>()->implicit_value(""));
    opt(argASM, "Write assembly code generated by llc",
        value<std::string>()->implicit_value(""));

    opt(argTraceScanner, "Enable scanner tracing");
    opt(argTraceParser, "Enable parser tracing");

    opt("version", "Print version");
    opt("h,help", "Print usage");

    try {
        res = options.parse(argc, argv);
    }
    catch (cxxopts::OptionException const &exc) {
        fmt::print(stderr, "Error: {}\n", exc.what());
        exit(EXIT_FAILURE);
    }

    if (res.count("help")) {
        fmt::print("{}\n", options.help());
        exit(EXIT_SUCCESS);
    }
    else if (res.count("version")) {
        fmt::print("{} version: {}\n", name, vers);
        exit(EXIT_SUCCESS);
    }
}

CLIArgs::CLIArgs(int argc, char **argv)
        : impl(std::make_unique<CLIArgs_Impl>(argc, argv)) {}

CLIArgs::~CLIArgs() = default;

std::string CLIArgs::getString(const std::string &sname) const {
    return impl->res[sname].as<std::string>();
}

std::optional<std::string> CLIArgs::getOutParam(const char *pname) const {
    if (impl->res.count(pname))
        return getString(pname);
    return std::optional<std::string>();
}

std::optional<std::string> CLIArgs::outPreproc() const {
    return getOutParam(argPreproc);
}

std::optional<std::string> CLIArgs::outAST() const {
    return getOutParam(argAst);
}

std::optional<std::string> CLIArgs::outRawIR() const {
    return getOutParam(argRawIr);
}

std::optional<std::string> CLIArgs::outRawCFG() const {
    return getOutParam(argRawCfg);
}

std::optional<std::string> CLIArgs::outIR() const {
    return getOutParam(argIr);
}

std::optional<std::string> CLIArgs::outCFG() const {
    return getOutParam(argCfg);
}

std::optional<std::string> CLIArgs::outLLVM() const {
    return getOutParam(argLLVM);
}

std::optional<std::string> CLIArgs::outASM() const {
    return getOutParam(argASM);
}


bool CLIArgs::isScannerTracing() const {
    return impl->res.count(argTraceScanner);
}

bool CLIArgs::isParserTracing() const {
    return impl->res.count(argTraceParser);
}


std::vector<std::string> CLIArgs::inputFiles() const {
    return impl->res.unmatched();
}


std::string CLIArgs::get_llc_name() const {
    const char *envVal = getenv(envLLC);
    if (envVal == nullptr || *envVal == '\0')
        return defaultLLC;
    return envVal;
}
